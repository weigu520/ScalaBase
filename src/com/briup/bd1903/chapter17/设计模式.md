# 设计模式

## 设计模式类型

1. 创建型模式：**单例模式**、**抽象工厂模式**、建造者模式、**工厂模式**、原型模式。
2. 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、**代理模式**。
3. 行为型模式：模版方法模式、命令模式、迭代器模式、**观察者模式**、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式

## 简单工厂模式

### 基本介绍

1. 简单工厂模式是属于创建型模式，但不属于23种GOF设计模式之一。**简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例**。简单工厂模式是工厂模式家族中最简单实用的模式
2. 简单工厂模式：定义了一个创建对象的类，由这个类来**封装实例化对象的行为**(代码)
3. 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式

### 具体需求

一个披萨的项目：要便于披萨种类的扩展，要便于维护，完成披萨订购功能。

![1572836749074](C:\Users\weigu\AppData\Roaming\Typora\typora-user-images\1572836749074.png)

## 工厂方法模式

### 新的需求

披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪pizza、北京的胡椒pizza 或者是伦敦的奶酪pizza、伦敦的胡椒pizza。

### 模式介绍

工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。
工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。

## 抽象工厂模式

### 基本介绍

1. 抽象工厂模式：定义了一个trait用于创建相关或有依赖关系的对象簇，而无需指明具体的类
2. 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
3. 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。
4. 将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展

### 工厂模式小结

1.工厂模式的意义

​	将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。
2.三种工厂模式 
3.设计模式的依赖抽象原则

1. 创建对象实例时，不要直接 new 类, 而是把这个new 类的动作放在一个工厂的方法中，并返回。也有的书上说，变量不要直接持有具体类的引用。
2. 不要让类继承具体类，而是继承抽象类或者是trait（接口）
3. 不要覆盖基类中已经实现的方法

## 单例模式

单例模式是指：保证在整个的软件系统中，某个类只能存在一个对象实例。

比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFactory就够，这是就会使用到单例模式。
Akka [ActorySystem 单例]

Scala中没有静态的概念，所以为了实现Java中单例模式的功能，可以直接采用类对象(即伴生对象)方式构建单例对象

## 装饰者模式(Decorator)

动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)

装饰者模式就像打包一个快递
主体：比如：陶瓷、衣服 (Component)
包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)

## 观察者模式(Observer)

气象站项目，具体要求如下：
气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站)。
需要设计开放型API，便于其他第三方公司也能接入气象站获取数据。

提供温度、气压和湿度的接口
测量数据更新时，要能实时的通知给第三方

观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为Subject，依赖的对象为Observer，Subject通知Observer变化,比如这里的奶站是Subject，是1的一方。用户时Observer，是多的一方

## 代理模式

代理模式：为一个对象提供一个替身，以控制对这个对象的访问
被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象
代理模式有不同的形式(比如 远程代理，静态代理，动态代理)，都是为了控制与管理对象访问

RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法。可以用此方法调用的任何对象必须实现该远程接口，RMI可以将底层的socket编程封装，简化操作

RMI远程方法调用是计算机之间通过网络实现对象调用的一种通讯机制。
使用RMI机制，一台计算机上的对象可以调用另外 一台计算机上的对象来获取远程数据。
RMI被设计成一种面向对象开发方式，允许程序员使用远程对象来实现通信

### 动态代理

动态代理：运行时动态的创建代理类(对象)，并将方法调用转发到指定类(对象)

Proxy 和 InvocationHandler组合充当代理的角色.
RealSubject是一个实际对象，它实现接口Subject
在使用时，我们不希望直接访问RealSubject的对象，比如：我们对这个对象的访问是有控制的
我们使用动态代理，在程序中通过动态代理创建RealSubject，并完成调用.
动态代理可以根据需要，创建多种组合
Proxy也会实现Subject接口的方法，因此，使用Proxy+Invocation可以完成对RealSubject 的动态调用。
但是通过Proxy调用RealSubject方法是否成功，是由InvocationHandler来控制的。(这里其实就是保护代理)
理解：创建一个代理对象替代被调用的真实对象，使用反射实现控制